}
}
return(perm[2:(length(perm)-1)])
}
perm1 <- c(0,1,2,3,6,7,4,5,8)
perm2 <- c(0,4,5,3,2,1,6,7,8)
perm3 <- c(5,1,4,3,7,8,9,2,6)
perm4 <- c(0, 1, 2, 5, 6, 3, 4, 7, 8, 9)
perm5 <- c(0, 1, 2, 3, 4, 8, 5, 6, 7, 9)
perm6 <- c(0,5,8,7,1,2,4,6,3,9)
perm <- perm4
FindSorted(perm)
IndicateAscending(perm)
BreakPointSort(perm)
SignedBreakpointSort(perm)
#setwd("V:/MPA-BTB/MPA-PRG/exercise_08")
FindSignedBreakpoint <- function(perm){
for (i in 1:(length(perm) - 1)){
if (perm[i + 1] != perm[i] + 1){
return(i + 1)
}
}
return(-1)
}
IndicateAscendingSigned <- function(perm){
n <- length(perm)
asc <- rep(0, n)
for (i in 1:(n - 1)){
if (perm[i + 1] == perm[i] + 1){
asc[i] <- 1
asc[i + 1] <- 1
}
}
return(asc)
}
SignedReversal <- function(perm, i, j){
perm[i:j] <- -rev(perm[i:j])
return(perm)
}
HasDescendingSigned <- function(perm){
any(diff(perm) != 1)
}
SignedBreakpointSort <- function(permutation){
n <- length(permutation)
perm <- c(0, permutation, n + 1)
while (TRUE){
start <- FindSignedBreakpoint(perm)
if (start == -1) break
# standardní případ
x <- perm[start - 1] + 1
end <- which(perm == x)
if (length(end) > 0){
end <- end[1]
perm <- SignedReversal(perm, start, end)
next
}
# degenerovaný případ
asc <- IndicateAscendingSigned(perm)
i <- 1
while (i < length(perm) && asc[i + 1] == 1){
i <- i + 1
}
if (i > 2){
perm <- SignedReversal(perm, 2, i)
} else {
perm <- SignedReversal(perm, 2, 3)
}
}
return(perm[2:(length(perm) - 1)])
}
perm1 <- c(-3, +1, -2, +4)
perm2 <- c(0,4,5,3,2,1,6,7,8)
perm3 <- c(5,1,4,3,7,8,9,2,6)
perm4 <- c(0, 1, 2, 5, 6, 3, 4, 7, 8, 9)
perm5 <- c(0, 1, 2, 3, 4, 8, 5, 6, 7, 9)
perm6 <- c(0,5,8,7,1,2,4,6,3,9)
perm <- perm1
FindSorted(perm)
IndicateAscending(perm)
SignedBreakpointSort(perm)
#setwd("V:/MPA-BTB/MPA-PRG/exercise_08")
FindSignedBreakpoint <- function(perm){
for (i in 1:(length(perm) - 1)){
if (perm[i + 1] != perm[i] + 1){
return(i + 1)
}
}
return(-1)
}
IndicateAscendingSigned <- function(perm){
n <- length(perm)
asc <- rep(0, n)
for (i in 1:(n - 1)){
if (perm[i + 1] == perm[i] + 1){
asc[i] <- 1
asc[i + 1] <- 1
}
}
return(asc)
}
SignedReversal <- function(perm, i, j){
perm[i:j] <- -rev(perm[i:j])
return(perm)
}
HasDescendingSigned <- function(perm){
any(diff(perm) != 1)
}
SignedBreakpointSort <- function(permutation){
n <- length(permutation)
perm <- c(0, permutation, n + 1)
while (TRUE){
start <- FindSignedBreakpoint(perm)
if (start == -1) break
# standardní případ
x <- perm[start - 1] + 1
end <- which(perm == x)
if (length(end) > 0){
end <- end[1]
perm <- SignedReversal(perm, start, end)
next
}
# degenerovaný případ
asc <- IndicateAscendingSigned(perm)
i <- 1
while (i < length(perm) && asc[i + 1] == 1){
i <- i + 1
}
if (i > 2){
perm <- SignedReversal(perm, 2, i)
} else {
perm <- SignedReversal(perm, 2, 3)
}
}
return(perm[2:(length(perm) - 1)])
}
perm1 <- c(-3, +1, -2, +4)
perm2 <- c(0,4,5,3,2,1,6,7,8)
perm3 <- c(5,1,4,3,7,8,9,2,6)
perm4 <- c(0, 1, 2, 5, 6, 3, 4, 7, 8, 9)
perm5 <- c(0, 1, 2, 3, 4, 8, 5, 6, 7, 9)
perm6 <- c(0,5,8,7,1,2,4,6,3,9)
perm <- perm1
SignedBreakpointSort(perm)
#setwd("V:/MPA-BTB/MPA-PRG/exercise_08")
FindSignedBreakpoint <- function(perm){
for (i in 1:(length(perm) - 1)){
if (perm[i + 1] != perm[i] + 1){
return(i + 1)
}
}
return(-1)
}
IndicateAscendingSigned <- function(perm){
n <- length(perm)
asc <- rep(0, n)
for (i in 1:(n - 1)){
if (perm[i + 1] == perm[i] + 1){
asc[i] <- 1
asc[i + 1] <- 1
}
}
return(asc)
}
SignedReversal <- function(perm, i, j){
perm[i:j] <- -rev(perm[i:j])
return(perm)
}
HasDescendingSigned <- function(perm){
any(diff(perm) != 1)
}
SignedBreakpointSort <- function(permutation){
n <- length(permutation)
perm <- c(0, permutation, n + 1)
while (TRUE){
start <- FindSignedBreakpoint(perm)
if (start == -1) break
x <- perm[start - 1] + 1
end <- which(abs(perm) == x)
if (length(end) > 0){
end <- end[1]
perm <- SignedReversal(perm, start, end)
# oprava znaménka
if (perm[start] != x){
perm[start] <- -perm[start]
}
next
}
# fallback – jen jako pojistka
asc <- IndicateAscendingSigned(perm)
i <- 1
while (i < length(perm) && asc[i + 1] == 1){
i <- i + 1
}
perm <- SignedReversal(perm, 2, max(3, i))
}
return(perm[2:(length(perm) - 1)])
}
perm1 <- c(-3, +1, -2, +4)
perm <- perm1
SignedBreakpointSort(perm)
setwd("D:/MPC-BTB/MPA-PRG/exercise_09")
# setwd("V:/MPA-BTB/MPA-PRG/exercise_09")
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#
#BiocManager::install("GenomicRanges")
#BiocManager::install("Biostrings")
library(Seqinfo)
# setwd("V:/MPA-BTB/MPA-PRG/exercise_09")
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#
#BiocManager::install("GenomicRanges")
#BiocManager::install("Biostrings")
#library(Seqinfo)
library(Biostrings)
Overlap <- function(seq1, seq2){
len1 <- length(seq1)
len2 <- length(seq2)
overlap_count <- 0
for (i in 0:len1){
#print(paste0(seq1[(len1-i):len1], collapse = ""))
#print(paste0(seq2[1:(i+1)], collapse = ""))
if (grepl(paste0(seq1[(len1-i):len1], collapse = ""), paste0(seq2[1:(i+1)], collapse = ""))){
overlap_count <- i + 1
}
}
return(overlap_count)
}
OverlapMat <- function(S){
len <- length(S)
SeqMat <- matrix(0,len, len)
for (i in 1:len){
seq1 <- strsplit(S[i], "")[[1]]
for (j in 1:len){
seq2 <- strsplit(S[j], "")[[1]]
if (i != j){
SeqMat[i,j] <- Overlap(seq1,seq2)
}
}
}
return(SeqMat)
}
GreedySuperstring <- function(S){
len <- length(S)
while (len > 1){
overlapMat <- OverlapMat(S)
if (max(as.numeric(unlist(overlapMat))) == 0){
return(S)
}
else{
maxim_indexes = which(m == max(m), arr.ind = TRUE)
seq1 <- S[maxim_indexes[1]]
seq2 <- S[maxim_indexes[2]]
list.remove(S, seq1)
list.remove(S, seq2)
}
}
return(S)
}
seq1 <- strsplit("TTCA", "")[[1]]
seq2 <- strsplit("CATGC", "")[[1]]
Overlap(seq1, seq2)
S <- c("CATGC","CTAAGT","GCTA","TTCA","ATGCATC")
OverlapMat(S)
GreedySuperstring(S)
# setwd("V:/MPA-BTB/MPA-PRG/exercise_09")
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#
#BiocManager::install("GenomicRanges")
#BiocManager::install("Biostrings")
#library(Seqinfo)
library(Biostrings)
Overlap <- function(seq1, seq2){
len1 <- length(seq1)
len2 <- length(seq2)
overlap_count <- 0
for (i in 0:len1){
#print(paste0(seq1[(len1-i):len1], collapse = ""))
#print(paste0(seq2[1:(i+1)], collapse = ""))
if (grepl(paste0(seq1[(len1-i):len1], collapse = ""), paste0(seq2[1:(i+1)], collapse = ""))){
overlap_count <- i + 1
}
}
return(overlap_count)
}
OverlapMat <- function(S){
len <- length(S)
SeqMat <- matrix(0,len, len)
for (i in 1:len){
seq1 <- strsplit(S[i], "")[[1]]
for (j in 1:len){
seq2 <- strsplit(S[j], "")[[1]]
if (i != j){
SeqMat[i,j] <- Overlap(seq1,seq2)
}
}
}
return(SeqMat)
}
GreedySuperstring <- function(S){
len <- length(S)
while (len > 1){
overlapMat <- OverlapMat(S)
if (max(as.numeric(unlist(overlapMat))) == 0){
return(S)
}
else{
maxim_indexes = which(m == max(m), arr.ind = TRUE)
seq1 <- S[maxim_indexes[1]]
seq2 <- S[maxim_indexes[2]]
list.remove(S, seq1)
list.remove(S, seq2)
}
}
return(S)
}
seq1 <- strsplit("TTCA", "")[[1]]
seq2 <- strsplit("CATGC", "")[[1]]
Overlap(seq1, seq2)
S <- c("CATGC","CTAAGT","GCTA","TTCA","ATGCATC")
OverlapMat(S)
GreedySuperstring(S)
# setwd("V:/MPA-BTB/MPA-PRG/exercise_09")
# if (!require("BiocManager", quietly = TRUE))
#   install.packages("BiocManager")
#
#BiocManager::install("GenomicRanges")
#BiocManager::install("Biostrings")
#library(Seqinfo)
library(Biostrings)
Overlap <- function(seq1, seq2){
len1 <- length(seq1)
len2 <- length(seq2)
max_overlap <- min(len1, len2)
for (k in max_overlap:1){
if (identical(seq1[(len1-k+1):len1], seq2[1:k])){
return(k)
}
}
return(0)
}
OverlapMat <- function(S){
len <- length(S)
SeqMat <- matrix(0,len, len)
for (i in 1:len){
seq1 <- strsplit(S[i], "")[[1]]
for (j in 1:len){
seq2 <- strsplit(S[j], "")[[1]]
if (i != j){
SeqMat[i,j] <- Overlap(seq1,seq2)
}
}
}
return(SeqMat)
}
GreedySuperstring <- function(S){
while (length(S) > 1){
overlapMat <- OverlapMat(S)
max_ov <- max(overlapMat)
if (max_ov == 0){
return(paste(S, collapse = ""))
}
idx <- which(overlapMat == max_ov, arr.ind = TRUE)[1,]
i <- idx[1]
j <- idx[2]
s1 <- S[i]
s2 <- S[j]
ov <- max_ov
merged <- paste0(s1, substr(s2, ov + 1, nchar(s2)))
S <- S[-c(i, j)]
S <- c(S, merged)
}
return(S)
}
seq1 <- strsplit("TTCA", "")[[1]]
seq2 <- strsplit("CATGC", "")[[1]]
Overlap(seq1, seq2)
S <- c("CATGC","CTAAGT","GCTA","TTCA","ATGCATC")
OverlapMat(S)
GreedySuperstring(S)
library(Biostrings)
# 2.1 Vytvoření uzlů a hran
DeBruijnGraph <- function(kmers){
nodes <- unique(unlist(lapply(kmers, function(x) c(substr(x, 1, nchar(x)-1),
substr(x, 2, nchar(x))))))
edges <- lapply(kmers, function(kmer){
from <- substr(kmer, 1, nchar(kmer)-1)
to   <- substr(kmer, 2, nchar(kmer))
c(from, to)
})
list(nodes = nodes, edges = edges)
}
# 2.2 Eulerian path
# jednoduchá verze: Hierholzerův algoritmus
FindEulerianPath <- function(graph){
# vytvoříme adjacency list
adj <- list()
for (node in graph$nodes) adj[[node]] <- character(0)
for (e in graph$edges){
adj[[e[1]]] <- c(adj[[e[1]]], e[2])
}
path <- character(0)
stack <- character(0)
curr <- graph$edges[[1]][1]  # startovní uzel
while(length(stack) > 0 || length(adj[[curr]]) > 0){
if(length(adj[[curr]]) == 0){
path <- c(path, curr)
curr <- tail(stack,1)
stack <- head(stack,-1)
} else {
stack <- c(stack, curr)
next_node <- adj[[curr]][1]
adj[[curr]] <- adj[[curr]][-1]
curr <- next_node
}
}
path <- c(path, curr)
rev(path)
}
# 2.3 Assembly z Eulerian path
AssembleFromPath <- function(path){
seq <- path[1]
for(i in 2:length(path)){
seq <- paste0(seq, substr(path[i], nchar(path[i]), nchar(path[i])))
}
seq
}
kmers <- c("ATT","TTC","TCG","CGA","GAT")
dbg <- DeBruijnGraph(kmers)
path <- FindEulerianPath(dbg)
assembly <- AssembleFromPath(path)
assembly
library(Biostrings)
# 2.1 Vytvoření uzlů a hran
DeBruijnGraph <- function(kmers){
nodes <- unique(unlist(lapply(kmers, function(x) c(substr(x, 1, nchar(x)-1),
substr(x, 2, nchar(x))))))
edges <- lapply(kmers, function(kmer){
from <- substr(kmer, 1, nchar(kmer)-1)
to   <- substr(kmer, 2, nchar(kmer))
c(from, to)
})
list(nodes = nodes, edges = edges)
}
CanHaveEulerianPath <- function(graph){
# graph = list(nodes = ..., edges = ...)
# 1. vytvoříme adjacency list
out_deg <- setNames(rep(0, length(graph$nodes)), graph$nodes)
in_deg  <- setNames(rep(0, length(graph$nodes)), graph$nodes)
for(edge in graph$edges){
from <- edge[1]
to   <- edge[2]
out_deg[from] <- out_deg[from] + 1
in_deg[to]   <- in_deg[to] + 1
}
# 2. spočítáme rozdíly
start_nodes <- sum((out_deg - in_deg) == 1)
end_nodes   <- sum((in_deg - out_deg) == 1)
# 3. všechny ostatní uzly musí mít out_deg == in_deg
balanced_nodes <- all((out_deg - in_deg)[!(out_deg - in_deg %in% c(1,-1))] == 0)
if ((start_nodes == 1 && end_nodes == 1 && balanced_nodes) ||
(start_nodes == 0 && end_nodes == 0 && balanced_nodes)){
return(TRUE)
} else {
return(FALSE)
}
}
kmers <- c("ATT","TTC","TCG","CGA","GAT")
dbg <- DeBruijnGraph(kmers)
CanHaveEulerianPath(dbg)
# 2.2 Eulerian path
# jednoduchá verze: Hierholzerův algoritmus
FindEulerianPath <- function(graph){
# vytvoříme adjacency list
adj <- list()
for (node in graph$nodes) adj[[node]] <- character(0)
for (e in graph$edges){
adj[[e[1]]] <- c(adj[[e[1]]], e[2])
}
path <- character(0)
stack <- character(0)
curr <- graph$edges[[1]][1]  # startovní uzel
while(length(stack) > 0 || length(adj[[curr]]) > 0){
if(length(adj[[curr]]) == 0){
path <- c(path, curr)
curr <- tail(stack,1)
stack <- head(stack,-1)
} else {
stack <- c(stack, curr)
next_node <- adj[[curr]][1]
adj[[curr]] <- adj[[curr]][-1]
curr <- next_node
}
}
path <- c(path, curr)
rev(path)
}
# 2.3 Assembly z Eulerian path
AssembleFromPath <- function(path){
seq <- path[1]
for(i in 2:length(path)){
seq <- paste0(seq, substr(path[i], nchar(path[i]), nchar(path[i])))
}
seq
}
kmers <- c("ATT","TTC","TCG","CGA","GAT")
dbg <- DeBruijnGraph(kmers)
path <- FindEulerianPath(dbg)
assembly <- AssembleFromPath(path)
assembly
